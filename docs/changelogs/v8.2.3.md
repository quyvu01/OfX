# Changelog v8.2.3

All notable changes in this release.

## [8.2.3] - 2026-01-19

### Added

#### Attribute Validation for Duplicate Entities
- Added validation to prevent the same `OfXAttribute` from being used by multiple entities
- Clear exception message at startup when duplicate configuration is detected
- Prevents ambiguous attribute-to-entity mappings

#### Order-Only Indexer Format `[asc/desc Property]`
- Added new indexer format for ordering without pagination
- `Skip` and `Take` properties in `IndexerNode` are now nullable
- Added `IsOrderOnly` property to `IndexerNode`
- Updated expression parser to handle 4 indexer formats:
  - `[asc Name]` - Order only
  - `[0 asc Name]` - Single item (first)
  - `[-1 desc Name]` - Single item (last)
  - `[0 10 asc Name]` - Range with pagination

#### Comprehensive Expression Integration Tests
- Added 59+ integration tests with in-memory DbContext
- Tests cover all expression features: filters, indexers, projections, aggregations
- Tests for edge cases: empty collections, null handling, complex chains

### Changed

#### IndexerNode Record
- Changed `Skip` from `int` to `int?` to support order-only format
- Added `IsOrderOnly` property: `Skip is null && Take is null`
- Added `IsSingleItem` property: `Skip is not null && Take is null`
- Added `IsLastItem` property: `IsSingleItem && Skip < 0`

#### ExpressionParser
- Updated grammar: `Indexer := '[' (Number (Number)?)? ('asc' | 'desc') Identifier ']'`
- Number tokens are now optional in indexer parsing
- Parser correctly identifies order-only vs pagination formats

#### LinqExpressionBuilder
- Added handling for `IsOrderOnly` case in `VisitIndexer`
- Returns `IOrderedEnumerable<T>` when only ordering is applied

---

## Files Changed

### Modified Files

| File | Changes |
|------|---------|
| `src/OfX/Expressions/Nodes/IndexerNode.cs` | Nullable Skip/Take, added IsOrderOnly/IsSingleItem/IsLastItem |
| `src/OfX/Expressions/Parsing/ExpressionParser.cs` | Updated grammar and ParseIndexer method |
| `src/OfX/Expressions/Building/LinqExpressionBuilder.cs` | Added IsOrderOnly handling |
| `src/OfX/Statics/OfXStatics.cs` | Added duplicate attribute validation |
| `src/OfX/Exceptions/OfXException.cs` | Added DuplicateAttributeConfiguration message |

### New/Updated Test Files

| File | Changes |
|------|---------|
| `test/OfX.Tests/UnitTests/Expressions/ExpressionParserTests.cs` | Added 4 tests for order-only format |
| `test/OfX.Tests/IntegrationTests/Expressions/ExpressionIntegrationTests.cs` | New comprehensive test file (59 tests) |
| `test/OfX.Tests/UnitTests/Exceptions/OfXExceptionTests.cs` | Added duplicate attribute tests |

---

## Code Changes

### IndexerNode.cs (Modified)

```csharp
// Before
public sealed record IndexerNode(
    ExpressionNode Source,
    int Skip,           // Required
    int? Take,
    OrderDirection OrderDirection,
    string OrderBy) : ExpressionNode;

// After
public sealed record IndexerNode(
    ExpressionNode Source,
    int? Skip,          // Nullable for order-only
    int? Take,
    OrderDirection OrderDirection,
    string OrderBy) : ExpressionNode
{
    public bool IsOrderOnly => Skip is null && Take is null;
    public bool IsSingleItem => Skip is not null && Take is null;
    public bool IsLastItem => IsSingleItem && Skip < 0;
}
```

### ExpressionParser.cs (Modified)

```csharp
/// <summary>
/// Parses an indexer with 4 supported formats:
/// - [asc Name] - Order only (no skip/take)
/// - [0 asc Name] - Single item access (first item)
/// - [-1 desc Name] - Single item access (last item)
/// - [0 10 asc Name] - Range access (skip 0, take 10)
/// </summary>
private IndexerNode ParseIndexer(ExpressionNode source)
{
    int? skip = null;
    int? take = null;

    // Check if starts with number (skip) or order direction
    if (Check(TokenType.Number))
    {
        var skipToken = Advance();
        skip = int.Parse(skipToken.Value);

        // Check if next is a number (take)
        if (Check(TokenType.Number))
        {
            var takeToken = Advance();
            take = int.Parse(takeToken.Value);
        }
    }

    // Parse order direction and property...
    return new IndexerNode(source, skip, take, direction, orderBy);
}
```

### LinqExpressionBuilder.cs (Modified)

```csharp
// Added handling for order-only indexer
if (node.IsOrderOnly)
{
    // Return the ordered collection without pagination
    return new ExpressionBuildResult(
        typeof(IOrderedEnumerable<>).MakeGenericType(elementType),
        orderedCall);
}
```

### OfXStatics.cs (Modified)

```csharp
// Added duplicate attribute validation
var duplicates = configuredTypes
    .GroupBy(x => x.AttributeType)
    .Where(g => g.Count() > 1)
    .ToList();

if (duplicates.Any())
{
    var dup = duplicates.First();
    var entities = string.Join(", ", dup.Select(x => x.EntityType.Name));
    throw new OfXException(
        $"The attribute '{dup.Key.Name}' is already configured for entity '{dup.First().EntityType.Name}'. " +
        $"Cannot configure it for entity '{dup.Skip(1).First().EntityType.Name}'. " +
        $"Each OfXAttribute must only be used with a single entity type.");
}
```

---

## Usage Examples

### Order-Only Indexer

```csharp
// Get all orders sorted by date (newest first)
var expr = "Orders[desc OrderDate]";

// Get sorted orders with projection
var expr = "Orders[desc OrderDate].{Id, Status}";

// Get count of sorted collection (same as unsorted, but demonstrates chaining)
var expr = "Orders[desc Total]:count";
```

### Duplicate Attribute Validation

```csharp
// INVALID - Will throw at startup
[OfXConfigFor<ProductOfAttribute>(nameof(Id), nameof(Name))]
public class Product { ... }

[OfXConfigFor<ProductOfAttribute>(nameof(Id), nameof(Name))]  // Error!
public class Service { ... }

// VALID - Use separate attributes
[OfXConfigFor<ProductOfAttribute>(nameof(Id), nameof(Name))]
public class Product { ... }

[OfXConfigFor<ServiceOfAttribute>(nameof(Id), nameof(Name))]
public class Service { ... }
```

---

## Commits

| Commit | Description |
|--------|-------------|
| `cbb978b` | Fix bug missing [$order_direction $property_name] |
| `dc227a0` | Update add all unit test for expression and add [direction Property] |
| `8ef335e` | Add OfX validation when trying to use one Attribute for multiple Entities |
