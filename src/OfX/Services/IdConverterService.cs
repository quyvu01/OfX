using System.Collections.Concurrent;
using System.Linq.Expressions;
using System.Reflection;
using OfX.Abstractions;
using OfX.Exceptions;
using OfX.Extensions;

namespace OfX.Services;

internal class IdConverterService(IServiceProvider serviceProvider) : IIdConverter
{
    private static readonly Lazy<ConcurrentDictionary<Type, StronglyTypeIdCachedData>>
        StronglyTypeMethodInfoStorage = new(() => new ConcurrentDictionary<Type, StronglyTypeIdCachedData>());

    private static readonly Lazy<ConcurrentDictionary<Type, Type>> IdTypeMapConverters = new(() => []);

    /// <summary>
    /// Need to improve this method. It's not good enough!
    /// As the real cases, the SQL generated by EF Core is not cached by parameters.
    /// </summary>
    /// <param name="selectorIds"></param>
    /// <param name="idType"></param>
    /// <returns></returns>
    public ConstantExpression ConstantExpression(List<string> selectorIds, Type idType)
    {
        if (idType == typeof(string)) return ParseStrings(selectorIds);

        if (idType == typeof(Guid)) return ParseGuids(selectorIds);

        if (idType == typeof(Guid?)) return ParseNullableGuids(selectorIds);

        if (idType == typeof(int)) return ParseIntegers(selectorIds);

        if (idType == typeof(int?)) return ParseNullableIntegers(selectorIds);

        if (idType == typeof(long)) return ParseLongs(selectorIds);

        if (idType == typeof(long?)) return ParseNullableLongs(selectorIds);

        if (idType == typeof(short)) return ParseShorts(selectorIds);

        if (idType == typeof(short?)) return ParseNullableShorts(selectorIds);

        if (idType == typeof(ulong)) return ParseULongs(selectorIds);

        if (idType == typeof(ulong?)) return ParseNullableULongs(selectorIds);

        if (idType == typeof(ushort)) return ParseUShorts(selectorIds);

        if (idType == typeof(ushort?)) return ParseNullableUShorts(selectorIds);

        if (idType == typeof(byte)) return ParseBytes(selectorIds);

        if (idType == typeof(byte?)) return ParseNullableBytes(selectorIds);

        if (idType == typeof(sbyte)) return ParseSBytes(selectorIds);

        if (idType == typeof(sbyte?)) return ParseNullableSBytes(selectorIds);
        return ParseStronglyTypes(serviceProvider, selectorIds, idType);
    }

    public object ConvertIds(List<string> selectorIds, Type idType)
    {
        if (idType == typeof(string)) return ParseStringIds(selectorIds);

        if (idType == typeof(Guid)) return ParseGuidIds(selectorIds);

        if (idType == typeof(Guid?)) return ParseNullableGuidIds(selectorIds);

        if (idType == typeof(int)) return ParseIntegerIds(selectorIds);

        if (idType == typeof(int?)) return ParseNullableIntegerIds(selectorIds);

        if (idType == typeof(long)) return ParseLongIds(selectorIds);

        if (idType == typeof(long?)) return ParseNullableLongIds(selectorIds);

        if (idType == typeof(short)) return ParseShortIds(selectorIds);

        if (idType == typeof(short?)) return ParseNullableShortIds(selectorIds);

        if (idType == typeof(ulong)) return ParseULongIds(selectorIds);

        if (idType == typeof(ulong?)) return ParseNullableULongIds(selectorIds);

        if (idType == typeof(ushort)) return ParseUShortIds(selectorIds);

        if (idType == typeof(ushort?)) return ParseNullableUShortIds(selectorIds);

        if (idType == typeof(byte)) return ParseByteIds(selectorIds);

        if (idType == typeof(byte?)) return ParseNullableByteIds(selectorIds);

        if (idType == typeof(sbyte)) return ParseSByteIds(selectorIds);

        if (idType == typeof(sbyte?)) return ParseNullableSByteIds(selectorIds);
        return ParseStronglyTypeIds(serviceProvider, selectorIds, idType);
    }

    #region ConstantExpression

    private static ConstantExpression ParseStrings(List<string> selectorIds) =>
        Expression.Constant(selectorIds);

    private static ConstantExpression ParseGuids(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => Guid.TryParse(a, out _))
            .Select(Guid.Parse)
            .ToList());

    private static ConstantExpression ParseIntegers(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => int.TryParse(a, out _))
            .Select(int.Parse)
            .ToList());

    private static ConstantExpression ParseLongs(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => long.TryParse(a, out _))
            .Select(long.Parse)
            .ToList());

    private static ConstantExpression ParseShorts(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => short.TryParse(a, out _))
            .Select(short.Parse)
            .ToList());

    private static ConstantExpression ParseULongs(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => ulong.TryParse(a, out _))
            .Select(ulong.Parse)
            .ToList());

    private static ConstantExpression ParseUShorts(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => ushort.TryParse(a, out _))
            .Select(ushort.Parse)
            .ToList());

    private static ConstantExpression ParseBytes(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => byte.TryParse(a, out _))
            .Select(byte.Parse)
            .ToList());

    private static ConstantExpression ParseSBytes(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => sbyte.TryParse(a, out _))
            .Select(sbyte.Parse)
            .ToList());

    // Parsing methods for nullable types
    private static ConstantExpression ParseNullableGuids(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => Guid.TryParse(a, out _))
            .Select(a => (Guid?)Guid.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableIntegers(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => int.TryParse(a, out _))
            .Select(a => (int?)int.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableLongs(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => long.TryParse(a, out _))
            .Select(a => (long?)long.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableShorts(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => short.TryParse(a, out _))
            .Select(a => (short?)short.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableULongs(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => ulong.TryParse(a, out _))
            .Select(a => (ulong?)ulong.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableUShorts(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => ushort.TryParse(a, out _))
            .Select(a => (ushort?)ushort.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableBytes(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => byte.TryParse(a, out _))
            .Select(a => (byte?)byte.Parse(a))
            .ToList());

    private static ConstantExpression ParseNullableSBytes(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => sbyte.TryParse(a, out _))
            .Select(a => (sbyte?)sbyte.Parse(a))
            .ToList());

    private static ConstantExpression ParseStronglyTypes(IServiceProvider serviceProvider, List<string> selectorIds,
        Type idType)
    {
        var serviceType = IdTypeMapConverters.Value
            .GetOrAdd(idType, type => typeof(IStronglyTypeConverter<>).MakeGenericType(type));
        var stronglyTypeService = serviceProvider.GetService(serviceType);
        if (stronglyTypeService is null) throw new OfXException.CurrentIdTypeWasNotSupported();
        var idDataCached = StronglyTypeMethodInfoStorage.Value.GetOrAdd(idType, _ =>
        {
            var methods = serviceType.GetMethods();
            var convertMethod = methods.FirstOrDefault(m =>
                m.Name == "Convert" && m.GetParameters() is { Length: 1 } parameters &&
                parameters[0].ParameterType == typeof(string));
            var canConvertMethod = methods.FirstOrDefault(m =>
                m.Name == "CanConvert" && m.GetParameters() is { Length: 1 } parameters &&
                parameters[0].ParameterType == typeof(string));
            var listType = typeof(List<>).MakeGenericType(idType);
            var addMethod = listType.GetMethod("Add") ??
                            throw new InvalidOperationException($"Unable to find 'Add' method on {listType}");
            return new StronglyTypeIdCachedData(convertMethod, canConvertMethod, listType, addMethod);
        });

        var stronglyTypedList = Activator.CreateInstance(idDataCached.ListType);
        selectorIds.Where(a => (bool)idDataCached.CanConvertMethod
                .Invoke(stronglyTypeService, [a])!)
            .ForEach(id =>
            {
                var convertedValue = idDataCached.ConvertMethod.Invoke(stronglyTypeService, [id]);
                idDataCached.AddMethod.Invoke(stronglyTypedList, [convertedValue]);
            });

        return Expression.Constant(stronglyTypedList, idDataCached.ListType);
    }

    #endregion

    #region ConvertIds

    private static object ParseStringIds(List<string> selectorIds) => selectorIds;

    private static object ParseGuidIds(List<string> selectorIds) => selectorIds
        .Where(a => Guid.TryParse(a, out _))
        .Select(Guid.Parse)
        .ToList();

    private static object ParseIntegerIds(List<string> selectorIds) => selectorIds
        .Where(a => int.TryParse(a, out _))
        .Select(int.Parse)
        .ToList();

    private static object ParseLongIds(List<string> selectorIds) => selectorIds
        .Where(a => long.TryParse(a, out _))
        .Select(long.Parse)
        .ToList();

    private static object ParseShortIds(List<string> selectorIds) => selectorIds
        .Where(a => short.TryParse(a, out _))
        .Select(short.Parse)
        .ToList();

    private static object ParseULongIds(List<string> selectorIds) => selectorIds
        .Where(a => ulong.TryParse(a, out _))
        .Select(ulong.Parse)
        .ToList();

    private static object ParseUShortIds(List<string> selectorIds) =>
        Expression.Constant(selectorIds
            .Where(a => ushort.TryParse(a, out _))
            .Select(ushort.Parse)
            .ToList());

    private static object ParseByteIds(List<string> selectorIds) => selectorIds
        .Where(a => byte.TryParse(a, out _))
        .Select(byte.Parse)
        .ToList();

    private static object ParseSByteIds(List<string> selectorIds) => selectorIds
        .Where(a => sbyte.TryParse(a, out _))
        .Select(sbyte.Parse)
        .ToList();

    // Parsing methods for nullable types
    private static object ParseNullableGuidIds(List<string> selectorIds) => selectorIds
        .Where(a => Guid.TryParse(a, out _))
        .Select(a => (Guid?)Guid.Parse(a))
        .ToList();

    private static object ParseNullableIntegerIds(List<string> selectorIds) => selectorIds
        .Where(a => int.TryParse(a, out _))
        .Select(a => (int?)int.Parse(a))
        .ToList();

    private static object ParseNullableLongIds(List<string> selectorIds) => selectorIds
        .Where(a => long.TryParse(a, out _))
        .Select(a => (long?)long.Parse(a))
        .ToList();

    private static object ParseNullableShortIds(List<string> selectorIds) => selectorIds
        .Where(a => short.TryParse(a, out _))
        .Select(a => (short?)short.Parse(a))
        .ToList();

    private static object ParseNullableULongIds(List<string> selectorIds) => selectorIds
        .Where(a => ulong.TryParse(a, out _))
        .Select(a => (ulong?)ulong.Parse(a))
        .ToList();

    private static object ParseNullableUShortIds(List<string> selectorIds) => selectorIds
        .Where(a => ushort.TryParse(a, out _))
        .Select(a => (ushort?)ushort.Parse(a))
        .ToList();

    private static object ParseNullableByteIds(List<string> selectorIds) => selectorIds
        .Where(a => byte.TryParse(a, out _))
        .Select(a => (byte?)byte.Parse(a))
        .ToList();

    private static object ParseNullableSByteIds(List<string> selectorIds) => selectorIds
        .Where(a => sbyte.TryParse(a, out _))
        .Select(a => (sbyte?)sbyte.Parse(a))
        .ToList();

    private static object ParseStronglyTypeIds(IServiceProvider serviceProvider, List<string> selectorIds,
        Type idType)
    {
        var serviceType = IdTypeMapConverters.Value
            .GetOrAdd(idType, type => typeof(IStronglyTypeConverter<>).MakeGenericType(type));
        var stronglyTypeService = serviceProvider.GetService(serviceType);
        if (stronglyTypeService is null) throw new OfXException.CurrentIdTypeWasNotSupported();
        var idDataCached = StronglyTypeMethodInfoStorage.Value.GetOrAdd(idType, _ =>
        {
            var methods = serviceType.GetMethods();
            var convertMethod = methods.FirstOrDefault(m =>
                m.Name == "Convert" && m.GetParameters() is { Length: 1 } parameters &&
                parameters[0].ParameterType == typeof(string));
            var canConvertMethod = methods.FirstOrDefault(m =>
                m.Name == "CanConvert" && m.GetParameters() is { Length: 1 } parameters &&
                parameters[0].ParameterType == typeof(string));
            var listType = typeof(List<>).MakeGenericType(idType);
            var addMethod = listType.GetMethod("Add") ??
                            throw new InvalidOperationException($"Unable to find 'Add' method on {listType}");
            return new StronglyTypeIdCachedData(convertMethod, canConvertMethod, listType, addMethod);
        });

        var stronglyTypedList = Activator.CreateInstance(idDataCached.ListType);
        selectorIds.Where(a => (bool)idDataCached.CanConvertMethod
                .Invoke(stronglyTypeService, [a])!)
            .ForEach(id =>
            {
                var convertedValue = idDataCached.ConvertMethod.Invoke(stronglyTypeService, [id]);
                idDataCached.AddMethod.Invoke(stronglyTypedList, [convertedValue]);
            });

        return stronglyTypedList;
    }

    #endregion


    private sealed record StronglyTypeIdCachedData(
        MethodInfo ConvertMethod,
        MethodInfo CanConvertMethod,
        Type ListType,
        MethodInfo AddMethod);
}